/*
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */

package net.sourceforge.pmd.lang.rule.internal;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;

import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.pcollections.HashTreePSet;
import org.pcollections.PSet;

import net.sourceforge.pmd.internal.util.AssertionUtil;
import net.sourceforge.pmd.util.CollectionUtil;

/**
 * Indexes data of type {@code <U>} with keys of type {@code <T>}, where
 * a partial order exists between the keys. The internal representation
 * is a directed acyclic graph on {@code <T>}. The value associated to
 * a key is the recursive union of the values of all the keys it covers.
 *
 * @param <K> Type of keys, must have a corresponding {@link TopoOrder},
 *            must be suitable for use as a map key (immutable, consistent equals/hashcode)
 * @param <V> Type of values
 */
class LatticeRelation<K, @NonNull V> {

    private final Predicate<? super K> filter;
    private final TopoOrder<K> keyOrder;
    private final Function<? super K, String> keyToString;

    /** Those nodes that can be queried (match the filter). */
    private final Map<K, QueryNode> qNodes = new HashMap<>();

    /**
     * Those nodes that were added explicitly through #put, but may not be queried.
     * These can be fetched efficiently, which is nice since we're trying to index
     * the same keys over and over. If the node has no query node parent, then it's
     * mapped to the {@link #blackHole}, which ignores incoming nodes.
     */
    private final Map<K, LNode> leaves = new HashMap<>();
    private final LNode blackHole = new BlackHoleNode();

    /**
     * Creates a new relation with the given configuration.
     *
     * @param keyOrder    Partial order generating the lattice
     * @param filter      Filter determining which keys can be queried
     *                    through {@link #get(Object)}
     * @param keyToString Strategy to render keys when dumping the lattice to a graph
     */
    LatticeRelation(TopoOrder<K> keyOrder,
                    Predicate<? super K> filter,
                    Function<? super K, String> keyToString) {
        this.keyOrder = keyOrder;
        this.filter = filter;
        this.keyToString = keyToString;
    }

    /**
     * Works like the other constructor, the filter being containment
     * in the given query set. This means, only keys that are in this
     * set may be queried.
     */
    LatticeRelation(TopoOrder<K> keyOrder,
                    Set<? extends K> querySet,
                    Function<? super K, String> keyToString) {
        this.keyOrder = keyOrder;
        this.filter = querySet::contains;
        this.keyToString = keyToString;

        for (K k : querySet) {
            put(k, null);
        }

        // since we know in advance which nodes are in the lattice, we
        // can perform this optimisation
        transitiveReduction();
    }

    /**
     * Follows all paths starting from the key (all nodes that are greater
     * w.r.t. the ordering). New nodes are created if they match the filter.
     * Existing nodes are invalidated.
     */
    private void addSucc(@Nullable LNode pred, PSet<K> seen, K key, V val) {
        if (seen.contains(key)) {
            throw new IllegalStateException("Cycle in graph generated by " + keyOrder);
        }
        LNode leaf = leaves.get(key);
        if (leaf != null) {
            leaf.addProperVal(val);
            invalidateSuccessors(leaf);
            return;
        }

        QueryNode n = qNodes.get(key);
        if (n != null) {
            if (pred == null) {
                n.addProperVal(val); // propagate new val to all successors, only if it was pruned
            }
            link(pred, n); // make sure the predecessor is linked
            invalidateSuccessors(n);
        } else if (filter.test(key)) {
            n = new QueryNode(key);
            n.addProperVal(val);
            qNodes.put(key, n);
            link(pred, n);

            Iterator<K> successors = keyOrder.directSuccessors(key);
            while (successors.hasNext()) {
                addSucc(n, seen.plus(key), successors.next(), null);
            }
        } else {
            if (pred == null) {
                // leaf
                pred = new LeafNode(key);
                pred.addProperVal(val);
                leaves.put(key, pred);
            }

            Iterator<K> successors = keyOrder.directSuccessors(key);
            if (!successors.hasNext() && pred.getClass() == LeafNode.class) {
                // delete the leaf (replaced by the sink)
                leaves.put(pred.key, blackHole);
                return;
            }

            while (successors.hasNext()) {
                addSucc(pred, seen.plus(key), successors.next(), val);
            }
        }
    }

    private void transitiveReduction() {

        // look for chains i -> j -> k, and delete i -> k if it exists

        for (QueryNode j : qNodes.values()) {
            for (LNode i : j.preds) {
                if (i != j) {
                    for (QueryNode k : j.succ) {
                        // i -> j -> k
                        if (k != j) {
                            if (i.succ.contains(k)) {
                                // i -> k
                                i.succ = i.succ.minus(k);
                                k.preds = k.preds.minus(i);
                            }
                        }
                    }
                }
            }
        }

    }

    private void invalidateSuccessors(LNode node) {
        node.invalidate();
        for (LNode s : node.succ) {
            invalidateSuccessors(s);
        }
    }

    private void link(LNode pred, QueryNode succ) {
        if (pred == null || succ == null) {
            return;
        }
        pred.succ = pred.succ.plus(succ);
        succ.preds = succ.preds.plus(pred);
    }

    /**
     * Adds the value to the given key. This value will be joined to the
     * values of all keys smaller than the given key when calling {@link #get(Object)}.
     *
     * @throws IllegalStateException If the order has a cycle
     */
    public void put(K key, V value) {
        AssertionUtil.requireParamNotNull("key", key);
        addSucc(null, HashTreePSet.empty(), key, value);
    }

    /**
     * Returns the computed value for the given key, or an empty set.
     * Only keys matching the filter given when constructing the lattice
     * can be queried.
     */
    @NonNull
    public Set<V> get(K key) {
        LNode n = qNodes.get(key);
        return n == null ? HashTreePSet.empty() : n.computeValue();
    }

    /** Clear known values. */
    void clearValues() {
        for (LNode value : qNodes.values()) {
            value.resetValue();
        }
    }


    @Override
    public String toString() {
        // generates a DOT representation of the lattice
        // Visualize eg at http://webgraphviz.com/
        StringBuilder sb = new StringBuilder("strict digraph {\n");
        Map<LNode, String> ids = new HashMap<>();
        Set<LNode> nodes = allNodes();
        int i = 0;
        for (LNode node : nodes) {
            String id = "n" + i++;
            ids.put(node, id);
            String color = node.getClass() == QueryNode.class ? "green" : "black";
            sb.append(id).append(" [ shape=box, color=").append(color).append(", label=\"")
              .append(escapeDotString(node.describe()))
              .append("\" ];\n");
        }

        for (LNode node : allNodes()) {
            // edges
            String id = ids.get(node);
            for (LNode succ : node.succ) {
                String succId = ids.get(succ);
                sb.append(id).append(" -> ").append(succId).append(";\n");
            }
        }

        return sb.append('}').toString();
    }

    private Set<LNode> allNodes() {
        return CollectionUtil.union(qNodes.values(), leaves.values());
    }

    @NonNull
    public String escapeDotString(String string) {
        return string.replaceAll("\\R", "\\\n")
                     .replaceAll("\"", "\\\"");
    }

    private abstract class LNode { // "Lattice Node"

        protected final @NonNull K key;
        /** Proper value associated with this node (independent of topology). */
        protected @NonNull Set<V> properVal = new LinkedHashSet<>();
        PSet<QueryNode> succ = HashTreePSet.empty();

        private LNode(@NonNull K key) {
            this.key = key;
        }

        void addProperVal(V v) {
            if (v == null) {
                return;
            }
            properVal.add(v);
        }

        protected String describe() {
            return keyToString.apply(key);
        }

        protected void invalidate() {

        }


        Set<V> computeValue() {
            return properVal;
        }

        protected void resetValue() {
            properVal = new LinkedHashSet<>();
        }

    }

    private final class QueryNode extends LNode {

        PSet<LNode> preds = HashTreePSet.empty();

        /** Cached value */
        private @Nullable PSet<V> combinedVal;
        private boolean isValueUpToDate = false;

        QueryNode(@NonNull K key) {
            super(key);
        }

        @Override
        protected void invalidate() {
            super.invalidate();
            isValueUpToDate = false;
        }

        @Override
        PSet<V> computeValue() {
            if (combinedVal != null && isValueUpToDate) {
                return combinedVal;
            }

            PSet<V> value = reduceSuccessors(new HashSet<>());
            combinedVal = value;
            isValueUpToDate = true;
            return value;
        }

        private PSet<V> reduceSuccessors(Set<LNode> seen) {
            if (combinedVal != null && isValueUpToDate) {
                return combinedVal;
            }

            isValueUpToDate = true;

            PSet<V> val = HashTreePSet.from(properVal);

            for (LNode child : preds) {
                if (seen.add(child)) {
                    if (child.getClass() == getClass()) {// illegal to cast to generic type
                        val = val.plusAll(((QueryNode) child).reduceSuccessors(seen));
                        isValueUpToDate &= ((QueryNode) child).isValueUpToDate;
                    } else {
                        // leaf
                        val = val.plusAll(child.computeValue());
                    }
                } else {
                    isValueUpToDate = false;
                }
            }

            if (isValueUpToDate) {
                this.combinedVal = val;
            }

            return val;
        }

        @Override
        protected void resetValue() {
            super.resetValue();
            combinedVal = null;
            isValueUpToDate = false;
        }

        @Override
        public String toString() {
            return "node(" + key + ')';
        }
    }

    private final class LeafNode extends LNode {

        LeafNode(@NonNull K key) {
            super(key);
        }

        @Override
        public String toString() {
            return "leaf(" + key + ')';
        }
    }

    private final class BlackHoleNode extends LNode {

        BlackHoleNode() {
            super(null);
        }

        @Override
        protected String describe() {
            return "<blackhole>";
        }

        @Override
        void addProperVal(V v) {
            // do nothing
        }

        @Override
        protected void resetValue() {
            // do nothing
        }

        @Override
        public String toString() {
            return "<blackHole>";
        }
    }

}
