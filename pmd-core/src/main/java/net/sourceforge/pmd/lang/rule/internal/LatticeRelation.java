/*
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */

package net.sourceforge.pmd.lang.rule.internal;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;

import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.pcollections.HashTreePSet;
import org.pcollections.PSet;

import net.sourceforge.pmd.internal.util.AssertionUtil;

/**
 * Indexes data of type {@code <U>} with keys of type {@code <T>}, where
 * a partial order exists between the keys. The internal representation
 * is a directed acyclic graph on {@code <T>}. The value associated to
 * a key is the recursive union of the values of all the keys it covers.
 *
 * @param <K> Type of keys, must have a corresponding {@link TopoOrder},
 *            must be suitable for use as a map key (immutable, consistent equals/hashcode)
 * @param <V> Type of values
 */
class LatticeRelation<K, @NonNull V> {

    private final Predicate<? super K> filter;
    private final TopoOrder<K> keyOrder;
    private final Function<? super K, String> keyToString;

    /** Those nodes that can be queried (match the filter). */
    private final Map<K, LNode> qNodes = new HashMap<>();
    /** Those nodes that were added explicitly through #put, but may not be queried. */
    private final Map<K, LNode> leaves = new HashMap<>();

    /**
     * Creates a new relation with the given configuration.
     *
     * @param keyOrder    Partial order generating the lattice
     * @param filter      Filter determining which keys can be queried
     *                    through {@link #get(Object)}
     * @param keyToString Strategy to render keys when dumping the lattice to a graph
     */
    LatticeRelation(TopoOrder<K> keyOrder,
                    Predicate<? super K> filter,
                    Function<? super K, String> keyToString) {
        this.keyOrder = keyOrder;
        this.filter = filter;
        this.keyToString = keyToString;
    }

    /**
     * Works like the other constructor, the filter being containment
     * in the given query set. This means, only keys that are in this
     * set may be queried.
     */
    LatticeRelation(TopoOrder<K> keyOrder,
                    Set<? extends K> querySet,
                    Function<? super K, String> keyToString) {
        this.keyOrder = keyOrder;
        this.filter = querySet::contains;
        this.keyToString = keyToString;

        for (K k : querySet) {
            put(k, null);
        }

        // since we know in advance which nodes are in the lattice, we
        // can perform this optimisation
        transitiveReduction();
    }

    /**
     * Follows all paths starting from the key (all nodes that are greater
     * w.r.t. the ordering). New nodes are created if they match the filter.
     * Existing nodes are invalidated.
     */
    private void addSucc(@Nullable LNode pred, PSet<K> seen, K key, V val) {
        if (seen.contains(key)) {
            throw new IllegalStateException("Cycle in graph generated by " + keyOrder);
        }
        if (qNodes.containsKey(key)) {
            LNode n = qNodes.get(key);
            if (pred == null) {
                n.addProperVal(val); // propagate new val to all successors, only if it was pruned
            }
            link(pred, n); // make sure the predecessor is linked
            invalidateSuccessors(n);
        } else if (filter.test(key)) {
            LNode n = new LNode(key);
            n.addProperVal(val);
            qNodes.put(key, n);
            link(pred, n);

            Iterator<K> successors = keyOrder.directSuccessors(key);
            while (successors.hasNext()) {
                addSucc(n, seen.plus(key), successors.next(), val);
            }
        } else {
            // even if we didn't create a node, we carry on with the successors
            // (to set pred, or invalidate value)
            Iterator<K> successors = keyOrder.directSuccessors(key);
            while (successors.hasNext()) {
                addSucc(pred, seen, successors.next(), val);
            }
        }
    }

    private void transitiveReduction() {

        // look for chains i -> j -> k, and delete i -> k if it exists

        for (LNode j : qNodes.values()) {
            for (LNode i : j.preds) {
                if (i != j) {
                    for (LNode k : j.succ) {
                        // i -> j -> k
                        if (k != j) {
                            if (i.succ.contains(k)) {
                                // i -> k
                                i.succ = i.succ.minus(k);
                                k.preds = k.preds.minus(i);
                            }
                        }
                    }
                }
            }
        }

    }

    private void invalidateSuccessors(LNode node) {
        node.isValueUpToDate = false;
        for (LNode s : node.succ) {
            invalidateSuccessors(s);
        }
    }

    private void link(LNode pred, LNode succ) {
        if (pred == null || succ == null) {
            return;
        }
        pred.succ = pred.succ.plus(succ);
        succ.preds = succ.preds.plus(pred);
    }

    /**
     * Adds the value to the given key. This value will be joined to the
     * values of all keys smaller than the given key when calling {@link #get(Object)}.
     *
     * @throws IllegalStateException If the order has a cycle
     */
    public void put(K key, V value) {
        AssertionUtil.requireParamNotNull("key", key);
        addSucc(null, HashTreePSet.empty(), key, value);
    }

    /**
     * Returns the computed value for the given key, or an empty set.
     * Only keys matching the filter given when constructing the lattice
     * can be queried.
     */
    @NonNull
    public PSet<V> get(K key) {
        LNode n = qNodes.get(key);
        return n == null ? HashTreePSet.empty() : n.computeValue();
    }

    /** Clear known values. */
    void clearValues() {
        for (LNode value : qNodes.values()) {
            value.resetValue();
        }
    }


    @Override
    public String toString() {
        // generates a DOT representation of the lattice
        // Visualize eg at http://webgraphviz.com/
        StringBuilder sb = new StringBuilder("strict digraph {\n");
        Map<LNode, String> ids = new HashMap<>();
        int i = 0;
        for (LNode node : qNodes.values()) {
            String id = "n" + i++;
            ids.put(node, id);
            sb.append(id).append(" [ shape=box, label=\"")
              .append(escapeDotString(keyToString.apply(node.key)))
              .append("\" ];\n");
        }

        for (LNode node : qNodes.values()) {
            // edges
            String id = ids.get(node);
            for (LNode succ : node.succ) {
                String succId = ids.get(succ);
                sb.append(id).append(" -> ").append(succId).append(";\n");
            }
        }

        return sb.append('}').toString();
    }

    @NonNull
    public String escapeDotString(String string) {
        return string.replaceAll("\\R", "\\\n")
                     .replaceAll("\"", "\\\"");
    }

    private final class LNode { // "Lattice Node"

        private final @NonNull K key;
        private PSet<LNode> succ = HashTreePSet.empty();
        private PSet<LNode> preds = HashTreePSet.empty();

        /** Proper value associated with this node (independent of topology). */
        private @NonNull Set<V> properVal = new LinkedHashSet<>();
        /** Cached value */
        private @Nullable PSet<V> frozenVal;

        private boolean isValueUpToDate = false;

        private LNode(@NonNull K key) {
            this.key = key;
        }

        private void addProperVal(V v) {
            if (v == null) {
                return;
            }
            properVal.add(v);
        }


        PSet<V> computeValue() {
            if (frozenVal != null && isValueUpToDate) {
                return frozenVal;
            }

            PSet<V> value = reduceSuccessors(new HashSet<>());
            frozenVal = value;
            isValueUpToDate = true;
            return value;
        }

        private PSet<V> reduceSuccessors(Set<LNode> seen) {
            if (frozenVal != null && isValueUpToDate) {
                return frozenVal;
            }

            isValueUpToDate = true;

            PSet<V> val = HashTreePSet.from(properVal);

            for (LNode child : preds) {
                if (seen.add(child)) {
                    val = val.plusAll(child.reduceSuccessors(seen));
                    isValueUpToDate &= child.isValueUpToDate;
                } else {
                    isValueUpToDate = false;
                }
            }

            if (isValueUpToDate) {
                this.frozenVal = val;
            }

            return val;
        }

        private void resetValue() {
            frozenVal = null;
            properVal = new LinkedHashSet<>();
            isValueUpToDate = false;
        }

        @Override
        public String toString() {
            return "(" + key + ')';
        }
    }

}
