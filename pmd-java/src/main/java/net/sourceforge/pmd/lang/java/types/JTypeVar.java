/*
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */

package net.sourceforge.pmd.lang.java.types;

import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Stream;

import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;

import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
import net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol;

/**
 * The type of a type variable. There are two sorts of those:
 *
 * <ul>
 * <li>Types of type parameters, which have a user-defined name, and an origin.
 * Those may only have an {@linkplain #getUpperBound() upper bound}.
 * <li>Types of {@linkplain #isCaptured() captured variables}, which arise
 * from {@linkplain TypeConversion#capture(JTypeMirror) capture-conversion}. Those can
 * have a non-trivial lower bound.
 * </ul>
 *
 * <p>Type variables may appear in their own bound (F-bound), and we
 * have to make sure all those occurrences are represented by the same instance.
 * We have to pay attention to cycles in our algos too.
 */
public interface JTypeVar extends JTypeMirror, SubstVar {


    /**
     * Returns the reflected type variable this instance represents,
     * or null if that is not available (eg in the case of captured
     * variables).
     */
    @Override
    @Nullable JTypeParameterSymbol getSymbol();


    /**
     * Returns the name of this variable, which may be null or something
     * autogenerated if this is a captured variable.
     */
    @Override
    @Nullable
    String getName();


    /**
     * Gets the upper bound. This defaults to Object, and may be an
     * {@linkplain JIntersectionType intersection type}.
     */
    @NonNull JTypeMirror getUpperBound();


    /**
     * Gets the lower bound. {@link TypeSystem#NULL_TYPE} conventionally represents
     * the bottom type (a trivial lower bound).
     */
    @NonNull
    JTypeMirror getLowerBound();


    /**
     * Returns true if this is a capture variable, ie this variable
     * originates from the {@linkplain TypeConversion#capture(JTypeMirror) capture} of a wildcard
     * type argument. Capture variables use reference identity.
     */
    boolean isCaptured();


    /**
     * Returns true if this is a capture variable for the given wildcard.
     * Reference identity is used there.
     */
    boolean isCaptureOf(JWildcardType wildcard);


    @Override
    default <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {
        return visitor.visitTypeVar(this, p);
    }

    default JTypeVar substInBounds(Function<? super SubstVar, ? extends @NonNull JTypeMirror> substitution) {
        JTypeMirror newLower = getLowerBound().subst(substitution);
        JTypeMirror newUpper = getUpperBound().subst(substitution);
        return cloneWithBounds(newLower, newUpper);
    }

    JTypeVar cloneWithBounds(JTypeMirror lower, JTypeMirror upper);


    @Override
    default Stream<JMethodSig> streamMethods(Predicate<? super JMethodSymbol> prefilter) {
        // recursively bound type vars will throw this into an infinite cycle
        //  eg <T extends X, X extends T>
        //  this is a compile-time error though
        return getUpperBound().streamMethods(prefilter);
    }


    /**
     * An intermediary type variable used during capture conversion.
     * Because type parameters can mention themselves in their bound
     * we have to somehow mutate the bounds after the substitution in
     * the bound.
     */
    interface FreshTypeVar extends JTypeVar {

        void setUpperBound(@NonNull JTypeMirror upperBound);


        void setLowerBound(@NonNull JTypeMirror lowerBound);

    }

}
