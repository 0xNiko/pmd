+- CompilationUnit[@TypeMirror = "void"]
   +- PackageDeclaration[]
   |  +- ModifierList[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ImportDeclaration[]
   +- ClassOrInterfaceDeclaration[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>"]
      +- ModifierList[]
      +- TypeParameters[]
      |  +- TypeParameter[@TypeMirror = "T"]
      |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
      +- ImplementsList[]
      |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
      |     +- TypeArguments[]
      |        +- ClassOrInterfaceType[@TypeMirror = "T"]
      +- ClassOrInterfaceBody[]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "java.util.Spliterator<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "java.util.Spliterators.<T> spliteratorUnknownSize(java.util.Iterator<? extends T>, int) -> java.util.Spliterator<T>", @MethodName = "spliteratorUnknownSize", @TypeMirror = "java.util.Spliterator<T>", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "java.util.Spliterators"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "java.util.Spliterators"]
         |           +- ArgumentList[]
         |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |              |  +- ArgumentList[]
         |              +- FieldAccess[@Name = "ORDERED", @TypeMirror = "int"]
         |                 +- TypeExpression[@TypeMirror = "java.util.Spliterator"]
         |                    +- ClassOrInterfaceType[@TypeMirror = "java.util.Spliterator"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "java.util.stream.Stream<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "java.util.stream.StreamSupport.<T> stream(java.util.Spliterator<T>, boolean) -> java.util.stream.Stream<T>", @MethodName = "stream", @TypeMirror = "java.util.stream.Stream<T>", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "java.util.stream.StreamSupport"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "java.util.stream.StreamSupport"]
         |           +- ArgumentList[]
         |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.spliterator() -> java.util.Spliterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "spliterator", @TypeMirror = "java.util.Spliterator<T>", @Unchecked = false, @VarargsCall = false]
         |              |  +- ArgumentList[]
         |              +- BooleanLiteral[@TypeMirror = "boolean"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- TypeParameters[]
         |  |  +- TypeParameter[@TypeMirror = "R"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<R>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream<? extends R>>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream<? extends R>>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |     |  +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     |     +- WildcardType[@TypeMirror = "? extends net.sourceforge.pmd.lang.ast.NodeStream<? extends R>"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<? extends R>"]
         |  |     |           +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     |           |  +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     |           +- TypeArguments[]
         |  |     |              +- WildcardType[@TypeMirror = "? extends R"]
         |  |     |                 +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |     +- VariableDeclaratorId[@Name = "mapper", @TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream<? extends R>>"]
         |  +- Block[]
         |     +- LocalVariableDeclaration[]
         |     |  +- ModifierList[]
         |     |  +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Function<? super T, java.util.Iterator<? extends R>>"]
         |     |  |  +- TypeArguments[]
         |     |  |     +- WildcardType[@TypeMirror = "? super T"]
         |     |  |     |  +- ClassOrInterfaceType[@TypeMirror = "T"]
         |     |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<? extends R>"]
         |     |  |        +- TypeArguments[]
         |     |  |           +- WildcardType[@TypeMirror = "? extends R"]
         |     |  |              +- ClassOrInterfaceType[@TypeMirror = "R"]
         |     |  +- VariableDeclarator[@TypeMirror = "void"]
         |     |     +- VariableDeclaratorId[@Name = "mapped", @TypeMirror = "java.util.function.Function<? super T, java.util.Iterator<? extends R>>"]
         |     |     +- MethodCall[@Failed = false, @Function = "java.util.function.Function<capture#... of ? super T, capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream<? extends R>>.<V> andThen(java.util.function.Function<? super capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream<? extends R>, ? extends java.util.Iterator<? extends R>>) -> java.util.function.Function<capture#... of ? super T, java.util.Iterator<? extends R>>", @MethodName = "andThen", @TypeMirror = "java.util.function.Function<capture#... of ? super T, java.util.Iterator<? extends R>>", @Unchecked = false, @VarargsCall = false]
         |     |        +- VariableAccess[@Name = "mapper", @TypeMirror = "java.util.function.Function<capture#... of ? super T, capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream<? extends R>>"]
         |     |        +- ArgumentList[]
         |     |           +- MethodReference[@TypeMirror = "java.util.function.Function<capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream<? extends R>, java.util.Iterator<? extends R>>"]
         |     |              +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream"]
         |     |                 +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream"]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<R extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<R extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<R>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- LambdaExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<R>>"]
         |                 +- LambdaParameterList[]
         |                 |  +- LambdaParameter[@TypeMirror = "java.util.Iterator<T>"]
         |                 |     +- ModifierList[]
         |                 |     +- VariableDeclaratorId[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                 +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T, R> flatMap(java.util.Iterator<? extends ο>, java.util.function.Function<? super ο, ? extends java.util.Iterator<? extends R>>) -> java.util.Iterator<R>", @MethodName = "flatMap", @TypeMirror = "java.util.Iterator<R>", @Unchecked = false, @VarargsCall = false]
         |                    +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    +- ArgumentList[]
         |                       +- VariableAccess[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                       +- VariableAccess[@Name = "mapped", @TypeMirror = "java.util.function.Function<capture#... of ? super T, java.util.Iterator<? extends R>>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  +- TypeParameters[]
         |  |  +- TypeParameter[@TypeMirror = "R"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<? extends R>"]
         |  |  +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.NonNull"]
         |  |  |  +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.NonNull"]
         |  |  +- TypeArguments[]
         |  |     +- WildcardType[@TypeMirror = "? extends R"]
         |  |        +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<? extends R>"]
         |  |     +- ModifierList[]
         |  |     |  +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     |     +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<? extends R>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? extends R"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |     +- VariableDeclaratorId[@Name = "ns", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<? extends R>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- ConditionalExpression[@TypeMirror = "java.util.Iterator<? extends R>"]
         |           +- InfixExpression[@TypeMirror = "boolean"]
         |           |  +- VariableAccess[@Name = "ns", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<capture#... of ? extends R>"]
         |           |  +- NullLiteral[@TypeMirror = "null"]
         |           +- MethodCall[@Failed = false, @Function = "java.util.Collections.<T> emptyIterator() -> java.util.Iterator<R>", @MethodName = "emptyIterator", @TypeMirror = "java.util.Iterator<R>", @Unchecked = false, @VarargsCall = false]
         |           |  +- TypeExpression[@TypeMirror = "java.util.Collections"]
         |           |  |  +- ClassOrInterfaceType[@TypeMirror = "java.util.Collections"]
         |           |  +- ArgumentList[]
         |           +- MethodCall[@Failed = false, @Function = "java.lang.Iterable<capture#... of ? extends R>.iterator() -> java.util.Iterator<capture#... of ? extends R>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<capture#... of ? extends R>", @Unchecked = false, @VarargsCall = false]
         |              +- VariableAccess[@Name = "ns", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<capture#... of ? extends R>"]
         |              +- ArgumentList[]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- TypeParameters[]
         |  |  +- TypeParameter[@TypeMirror = "R"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<R>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |        +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.NonNull"]
         |  |           +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.NonNull"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Function<? super T, ? extends R>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Function<? super T, ? extends R>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |     |  +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     |     +- WildcardType[@TypeMirror = "? extends R"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |     |           +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     |              +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     +- VariableDeclaratorId[@Name = "mapper", @TypeMirror = "java.util.function.Function<? super T, ? extends R>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<R extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<R extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<R>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- LambdaExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<R>>"]
         |                 +- LambdaParameterList[]
         |                 |  +- LambdaParameter[@TypeMirror = "java.util.Iterator<T>"]
         |                 |     +- ModifierList[]
         |                 |     +- VariableDeclaratorId[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                 +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T, R> mapNotNull(java.util.Iterator<? extends ψ>, java.util.function.Function<? super ψ, ? extends R>) -> java.util.Iterator<R>", @MethodName = "mapNotNull", @TypeMirror = "java.util.Iterator<R>", @Unchecked = false, @VarargsCall = false]
         |                    +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    +- ArgumentList[]
         |                       +- VariableAccess[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                       +- VariableAccess[@Name = "mapper", @TypeMirror = "java.util.function.Function<capture#... of ? super T, capture#... of ? extends R>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     |           +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.NonNull"]
         |  |     |              +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.NonNull"]
         |  |     +- VariableDeclaratorId[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<? super T>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- LambdaExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<T>>"]
         |                 +- LambdaParameterList[]
         |                 |  +- LambdaParameter[@TypeMirror = "java.util.Iterator<T>"]
         |                 |     +- ModifierList[]
         |                 |     +- VariableDeclaratorId[@Name = "it", @TypeMirror = "java.util.Iterator<T>"]
         |                 +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T, R> mapNotNull(java.util.Iterator<? extends ι1>, java.util.function.Function<? super ι1, ? extends T>) -> java.util.Iterator<T>", @MethodName = "mapNotNull", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |                    +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    +- ArgumentList[]
         |                       +- VariableAccess[@Name = "it", @TypeMirror = "java.util.Iterator<T>"]
         |                       +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.Filtermap.<I extends O, O> filter(java.util.function.Predicate<? super T>) -> net.sourceforge.pmd.lang.ast.internal.Filtermap<T, T>", @MethodName = "filter", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.Filtermap<T, T>", @Unchecked = false, @VarargsCall = false]
         |                          +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.Filtermap"]
         |                          |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.Filtermap"]
         |                          +- ArgumentList[]
         |                             +- VariableAccess[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<capture#... of ? super T>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- TypeParameters[]
         |  |  +- TypeParameter[@TypeMirror = "R"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<R>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.lang.Class<? extends R>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Class<? extends R>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? extends R"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |     +- VariableDeclaratorId[@Name = "rClass", @TypeMirror = "java.lang.Class<? extends R>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<R extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<R extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<R>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- LambdaExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<R>>"]
         |                 +- LambdaParameterList[]
         |                 |  +- LambdaParameter[@TypeMirror = "java.util.Iterator<T>"]
         |                 |     +- ModifierList[]
         |                 |     +- VariableDeclaratorId[@Name = "it", @TypeMirror = "java.util.Iterator<T>"]
         |                 +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T, R> mapNotNull(java.util.Iterator<? extends υ1>, java.util.function.Function<? super υ1, ? extends R>) -> java.util.Iterator<R>", @MethodName = "mapNotNull", @TypeMirror = "java.util.Iterator<R>", @Unchecked = false, @VarargsCall = false]
         |                    +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    +- ArgumentList[]
         |                       +- VariableAccess[@Name = "it", @TypeMirror = "java.util.Iterator<T>"]
         |                       +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.Filtermap.<I, O> isInstance(java.lang.Class<? extends R>) -> net.sourceforge.pmd.lang.ast.internal.Filtermap<T, R>", @MethodName = "isInstance", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.Filtermap<T, R>", @Unchecked = false, @VarargsCall = false]
         |                          +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.Filtermap"]
         |                          |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.Filtermap"]
         |                          +- ArgumentList[]
         |                             +- VariableAccess[@Name = "rClass", @TypeMirror = "java.lang.Class<capture#... of ? extends R>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<net.sourceforge.pmd.lang.ast.Node>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> flatMapDescendants(java.util.function.Function<T extends net.sourceforge.pmd.lang.ast.Node, net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<net.sourceforge.pmd.lang.ast.Node>", @MethodName = "flatMapDescendants", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<net.sourceforge.pmd.lang.ast.Node>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- MethodReference[@TypeMirror = "java.util.function.Function<T, net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends net.sourceforge.pmd.lang.ast.Node>>"]
         |                 +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |                    +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<net.sourceforge.pmd.lang.ast.Node>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> flatMapDescendants(java.util.function.Function<T extends net.sourceforge.pmd.lang.ast.Node, net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<net.sourceforge.pmd.lang.ast.Node>", @MethodName = "flatMapDescendants", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<net.sourceforge.pmd.lang.ast.Node>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- MethodReference[@TypeMirror = "java.util.function.Function<T, net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends net.sourceforge.pmd.lang.ast.Node>>"]
         |                 +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |                    +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- TypeParameters[]
         |  |  +- TypeParameter[@TypeMirror = "R"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<R>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.lang.Class<? extends R>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Class<? extends R>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? extends R"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |     +- VariableDeclaratorId[@Name = "rClass", @TypeMirror = "java.lang.Class<? extends R>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> flatMapDescendants(java.util.function.Function<T extends net.sourceforge.pmd.lang.ast.Node, net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends R extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<R extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "flatMapDescendants", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<R>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- LambdaExpression[@TypeMirror = "java.util.function.Function<T, net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends R>>"]
         |                 +- LambdaParameterList[]
         |                 |  +- LambdaParameter[@TypeMirror = "T"]
         |                 |     +- ModifierList[]
         |                 |     +- VariableDeclaratorId[@Name = "node", @TypeMirror = "T"]
         |                 +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.Node.<R extends net.sourceforge.pmd.lang.ast.Node> descendants(java.lang.Class<? extends R>) -> net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<R>", @MethodName = "descendants", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<R>", @Unchecked = false, @VarargsCall = false]
         |                    +- VariableAccess[@Name = "node", @TypeMirror = "T"]
         |                    +- ArgumentList[]
         |                       +- VariableAccess[@Name = "rClass", @TypeMirror = "java.lang.Class<capture#... of ? extends R>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.NonNull"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.NonNull"]
         |  +- TypeParameters[]
         |  |  +- TypeParameter[@TypeMirror = "R"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<R>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Function<T, net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends R>>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Function<T, net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends R>>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends R>"]
         |  |     |        +- TypeArguments[]
         |  |     |           +- WildcardType[@TypeMirror = "? extends R"]
         |  |     |              +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |     +- VariableDeclaratorId[@Name = "mapper", @TypeMirror = "java.util.function.Function<T, net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends R>>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- ConstructorCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T, R>.new(net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>, java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends R>>) -> net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T, R>", @MethodName = "new", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T, R>", @Unchecked = false, @VarargsCall = false]
         |           +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T extends net.sourceforge.pmd.lang.ast.Node, S extends net.sourceforge.pmd.lang.ast.Node>"]
         |           |  +- TypeArguments[]
         |           +- ArgumentList[]
         |              +- ThisExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>"]
         |              +- VariableAccess[@Name = "mapper", @TypeMirror = "java.util.function.Function<T, net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends R>>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- VoidType[@TypeMirror = "void"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Consumer<? super T>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Consumer<? super T>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     +- VariableDeclaratorId[@Name = "action", @TypeMirror = "java.util.function.Consumer<? super T>"]
         |  +- Block[]
         |     +- ExpressionStatement[]
         |        +- MethodCall[@Failed = false, @Function = "java.util.Iterator<T>.forEachRemaining(java.util.function.Consumer<? super T>) -> void", @MethodName = "forEachRemaining", @TypeMirror = "void", @Unchecked = false, @VarargsCall = false]
         |           +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |           |  +- ArgumentList[]
         |           +- ArgumentList[]
         |              +- VariableAccess[@Name = "action", @TypeMirror = "java.util.function.Consumer<capture#... of ? super T>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |  |  +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  |  +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "int"]
         |  |     +- ModifierList[]
         |  |     +- PrimitiveType[@TypeMirror = "int"]
         |  |     +- VariableDeclaratorId[@Name = "n", @TypeMirror = "int"]
         |  +- Block[]
         |     +- IfStatement[]
         |     |  +- InfixExpression[@TypeMirror = "boolean"]
         |     |  |  +- VariableAccess[@Name = "n", @TypeMirror = "int"]
         |     |  |  +- NumericLiteral[@TypeMirror = "int"]
         |     |  +- Block[]
         |     |     +- ReturnStatement[]
         |     |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.first() -> T extends net.sourceforge.pmd.lang.ast.Node", @MethodName = "first", @TypeMirror = "T", @Unchecked = false, @VarargsCall = false]
         |     |           +- ArgumentList[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> getNth(java.util.Iterator<? extends T>, int) -> T", @MethodName = "getNth", @TypeMirror = "T", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           +- ArgumentList[]
         |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |              |  +- ArgumentList[]
         |              +- VariableAccess[@Name = "n", @TypeMirror = "int"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "int"]
         |  |     +- ModifierList[]
         |  |     +- PrimitiveType[@TypeMirror = "int"]
         |  |     +- VariableDeclaratorId[@Name = "n", @TypeMirror = "int"]
         |  +- Block[]
         |     +- ExpressionStatement[]
         |     |  +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.AssertionUtil.requireNonNegative(java.lang.String, int) -> int", @MethodName = "requireNonNegative", @TypeMirror = "int", @Unchecked = false, @VarargsCall = false]
         |     |     +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.AssertionUtil"]
         |     |     |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.AssertionUtil"]
         |     |     +- ArgumentList[]
         |     |        +- StringLiteral[@TypeMirror = "java.lang.String"]
         |     |        +- VariableAccess[@Name = "n", @TypeMirror = "int"]
         |     +- ReturnStatement[]
         |        +- ConditionalExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |           +- InfixExpression[@TypeMirror = "boolean"]
         |           |  +- VariableAccess[@Name = "n", @TypeMirror = "int"]
         |           |  +- NumericLiteral[@TypeMirror = "int"]
         |           +- ThisExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>"]
         |           +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>", @Unchecked = false, @VarargsCall = false]
         |              +- ArgumentList[]
         |                 +- LambdaExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<T>>"]
         |                    +- LambdaParameterList[]
         |                    |  +- LambdaParameter[@TypeMirror = "java.util.Iterator<T>"]
         |                    |     +- ModifierList[]
         |                    |     +- VariableDeclaratorId[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                    +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> drop(java.util.Iterator<? extends T>, int) -> java.util.Iterator<T>", @MethodName = "drop", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |                       +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                       |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                       +- ArgumentList[]
         |                          +- VariableAccess[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                          +- VariableAccess[@Name = "n", @TypeMirror = "int"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "int"]
         |  |     +- ModifierList[]
         |  |     +- PrimitiveType[@TypeMirror = "int"]
         |  |     +- VariableDeclaratorId[@Name = "maxSize", @TypeMirror = "int"]
         |  +- Block[]
         |     +- ExpressionStatement[]
         |     |  +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.AssertionUtil.requireNonNegative(java.lang.String, int) -> int", @MethodName = "requireNonNegative", @TypeMirror = "int", @Unchecked = false, @VarargsCall = false]
         |     |     +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.AssertionUtil"]
         |     |     |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.AssertionUtil"]
         |     |     +- ArgumentList[]
         |     |        +- StringLiteral[@TypeMirror = "java.lang.String"]
         |     |        +- VariableAccess[@Name = "maxSize", @TypeMirror = "int"]
         |     +- ReturnStatement[]
         |        +- ConditionalExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |           +- InfixExpression[@TypeMirror = "boolean"]
         |           |  +- VariableAccess[@Name = "maxSize", @TypeMirror = "int"]
         |           |  +- NumericLiteral[@TypeMirror = "int"]
         |           +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.NodeStream.<T extends net.sourceforge.pmd.lang.ast.Node> empty() -> net.sourceforge.pmd.lang.ast.NodeStream<T>", @MethodName = "empty", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>", @Unchecked = false, @VarargsCall = false]
         |           |  +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream"]
         |           |  |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream"]
         |           |  +- ArgumentList[]
         |           +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>", @Unchecked = false, @VarargsCall = false]
         |              +- ArgumentList[]
         |                 +- LambdaExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<T>>"]
         |                    +- LambdaParameterList[]
         |                    |  +- LambdaParameter[@TypeMirror = "java.util.Iterator<T>"]
         |                    |     +- ModifierList[]
         |                    |     +- VariableDeclaratorId[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                    +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> take(java.util.Iterator<? extends T>, int) -> java.util.Iterator<T>", @MethodName = "take", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |                       +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                       |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                       +- ArgumentList[]
         |                          +- VariableAccess[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                          +- VariableAccess[@Name = "maxSize", @TypeMirror = "int"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     +- VariableDeclaratorId[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<? super T>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- LambdaExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<T>>"]
         |                 +- LambdaParameterList[]
         |                 |  +- LambdaParameter[@TypeMirror = "java.util.Iterator<T>"]
         |                 |     +- ModifierList[]
         |                 |     +- VariableDeclaratorId[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                 +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> takeWhile(java.util.Iterator<T>, java.util.function.Predicate<? super T>) -> java.util.Iterator<T>", @MethodName = "takeWhile", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |                    +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    +- ArgumentList[]
         |                       +- VariableAccess[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                       +- VariableAccess[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<capture#... of ? super T>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- TypeParameters[]
         |  |  +- TypeParameter[@TypeMirror = "R"]
         |  |  +- TypeParameter[@TypeMirror = "A"]
         |  +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.stream.Collector<? super T, A, R>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.stream.Collector<? super T, A, R>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |     |  +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     |     +- ClassOrInterfaceType[@TypeMirror = "A"]
         |  |     |     +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |     +- VariableDeclaratorId[@Name = "collector", @TypeMirror = "java.util.stream.Collector<? super T, A, R>"]
         |  +- Block[]
         |     +- LocalVariableDeclaration[]
         |     |  +- ModifierList[]
         |     |  +- ClassOrInterfaceType[@TypeMirror = "A"]
         |     |  +- VariableDeclarator[@TypeMirror = "void"]
         |     |     +- VariableDeclaratorId[@Name = "container", @TypeMirror = "A"]
         |     |     +- MethodCall[@Failed = false, @Function = "java.util.function.Supplier<A>.get() -> A", @MethodName = "get", @TypeMirror = "A", @Unchecked = false, @VarargsCall = false]
         |     |        +- MethodCall[@Failed = false, @Function = "java.util.stream.Collector<capture#... of ? super T, A, R>.supplier() -> java.util.function.Supplier<A>", @MethodName = "supplier", @TypeMirror = "java.util.function.Supplier<A>", @Unchecked = false, @VarargsCall = false]
         |     |        |  +- VariableAccess[@Name = "collector", @TypeMirror = "java.util.stream.Collector<capture#... of ? super T, A, R>"]
         |     |        |  +- ArgumentList[]
         |     |        +- ArgumentList[]
         |     +- LocalVariableDeclaration[]
         |     |  +- ModifierList[]
         |     |  +- ClassOrInterfaceType[@TypeMirror = "java.util.function.BiConsumer<A, ? super T>"]
         |     |  |  +- TypeArguments[]
         |     |  |     +- ClassOrInterfaceType[@TypeMirror = "A"]
         |     |  |     +- WildcardType[@TypeMirror = "? super T"]
         |     |  |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |     |  +- VariableDeclarator[@TypeMirror = "void"]
         |     |     +- VariableDeclaratorId[@Name = "accumulator", @TypeMirror = "java.util.function.BiConsumer<A, ? super T>"]
         |     |     +- MethodCall[@Failed = false, @Function = "java.util.stream.Collector<capture#... of ? super T, A, R>.accumulator() -> java.util.function.BiConsumer<A, capture#... of ? super T>", @MethodName = "accumulator", @TypeMirror = "java.util.function.BiConsumer<A, capture#... of ? super T>", @Unchecked = false, @VarargsCall = false]
         |     |        +- VariableAccess[@Name = "collector", @TypeMirror = "java.util.stream.Collector<capture#... of ? super T, A, R>"]
         |     |        +- ArgumentList[]
         |     +- ExpressionStatement[]
         |     |  +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.forEach(java.util.function.Consumer<? super T extends net.sourceforge.pmd.lang.ast.Node>) -> void", @MethodName = "forEach", @TypeMirror = "void", @Unchecked = false, @VarargsCall = false]
         |     |     +- ArgumentList[]
         |     |        +- LambdaExpression[@TypeMirror = "java.util.function.Consumer<T>"]
         |     |           +- LambdaParameterList[]
         |     |           |  +- LambdaParameter[@TypeMirror = "T"]
         |     |           |     +- ModifierList[]
         |     |           |     +- VariableDeclaratorId[@Name = "u", @TypeMirror = "T"]
         |     |           +- MethodCall[@Failed = false, @Function = "java.util.function.BiConsumer<A, capture#... of ? super T>.accept(A, capture#... of ? super T) -> void", @MethodName = "accept", @TypeMirror = "void", @Unchecked = false, @VarargsCall = false]
         |     |              +- VariableAccess[@Name = "accumulator", @TypeMirror = "java.util.function.BiConsumer<A, capture#... of ? super T>"]
         |     |              +- ArgumentList[]
         |     |                 +- VariableAccess[@Name = "container", @TypeMirror = "A"]
         |     |                 +- VariableAccess[@Name = "u", @TypeMirror = "T"]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.util.CollectionUtil.<V, A, C> finish(java.util.stream.Collector<? super T, A, ? extends R>, A) -> R", @MethodName = "finish", @TypeMirror = "R", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.util.CollectionUtil"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.util.CollectionUtil"]
         |           +- ArgumentList[]
         |              +- VariableAccess[@Name = "collector", @TypeMirror = "java.util.stream.Collector<capture#... of ? super T, A, R>"]
         |              +- VariableAccess[@Name = "container", @TypeMirror = "A"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- MethodReference[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<T>>"]
         |                 +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Consumer<? super T>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Consumer<? super T>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     +- VariableDeclaratorId[@Name = "action", @TypeMirror = "java.util.function.Consumer<? super T>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- LambdaExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<T>>"]
         |                 +- LambdaParameterList[]
         |                 |  +- LambdaParameter[@TypeMirror = "java.util.Iterator<T>"]
         |                 |     +- ModifierList[]
         |                 |     +- VariableDeclaratorId[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                 +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> peek(java.util.Iterator<? extends T>, java.util.function.Consumer<? super T>) -> java.util.Iterator<T>", @MethodName = "peek", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |                    +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    +- ArgumentList[]
         |                       +- VariableAccess[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                       +- VariableAccess[@Name = "action", @TypeMirror = "java.util.function.Consumer<capture#... of ? super T>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<? extends T>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<? extends T>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? extends T"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     +- VariableDeclaratorId[@Name = "right", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<? extends T>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- LambdaExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<T>>"]
         |                 +- LambdaParameterList[]
         |                 |  +- LambdaParameter[@TypeMirror = "java.util.Iterator<T>"]
         |                 |     +- ModifierList[]
         |                 |     +- VariableDeclaratorId[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                 +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> concat(java.util.Iterator<? extends T>, java.util.Iterator<? extends T>) -> java.util.Iterator<T>", @MethodName = "concat", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |                    +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    +- ArgumentList[]
         |                       +- VariableAccess[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                       +- MethodCall[@Failed = false, @Function = "java.lang.Iterable<capture#... of ? extends T>.iterator() -> java.util.Iterator<capture#... of ? extends T>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<capture#... of ? extends T>", @Unchecked = false, @VarargsCall = false]
         |                          +- VariableAccess[@Name = "right", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<capture#... of ? extends T>"]
         |                          +- ArgumentList[]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<? extends T>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<? extends T>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? extends T"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     +- VariableDeclaratorId[@Name = "right", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<? extends T>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.<R extends net.sourceforge.pmd.lang.ast.Node> mapIter(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.NodeStream<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "mapIter", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>", @Unchecked = false, @VarargsCall = false]
         |           +- ArgumentList[]
         |              +- LambdaExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<T>>"]
         |                 +- LambdaParameterList[]
         |                 |  +- LambdaParameter[@TypeMirror = "java.util.Iterator<T>"]
         |                 |     +- ModifierList[]
         |                 |     +- VariableDeclaratorId[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |                 +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> concat(java.util.Iterator<? extends T>, java.util.Iterator<? extends T>) -> java.util.Iterator<T>", @MethodName = "concat", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |                    +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |                    +- ArgumentList[]
         |                       +- MethodCall[@Failed = false, @Function = "java.lang.Iterable<capture#... of ? extends T>.iterator() -> java.util.Iterator<capture#... of ? extends T>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<capture#... of ? extends T>", @Unchecked = false, @VarargsCall = false]
         |                       |  +- VariableAccess[@Name = "right", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<capture#... of ? extends T>"]
         |                       |  +- ArgumentList[]
         |                       +- VariableAccess[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- PrimitiveType[@TypeMirror = "boolean"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     +- VariableDeclaratorId[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<? super T>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> anyMatch(java.util.Iterator<? extends T>, java.util.function.Predicate<? super T>) -> boolean", @MethodName = "anyMatch", @TypeMirror = "boolean", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           +- ArgumentList[]
         |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |              |  +- ArgumentList[]
         |              +- VariableAccess[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<capture#... of ? super T>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- PrimitiveType[@TypeMirror = "boolean"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     +- VariableDeclaratorId[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<? super T>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> noneMatch(java.util.Iterator<? extends T>, java.util.function.Predicate<? super T>) -> boolean", @MethodName = "noneMatch", @TypeMirror = "boolean", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           +- ArgumentList[]
         |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |              |  +- ArgumentList[]
         |              +- VariableAccess[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<capture#... of ? super T>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- PrimitiveType[@TypeMirror = "boolean"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     +- VariableDeclaratorId[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<? super T>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> allMatch(java.util.Iterator<? extends T>, java.util.function.Predicate<? super T>) -> boolean", @MethodName = "allMatch", @TypeMirror = "boolean", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           +- ArgumentList[]
         |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |              |  +- ArgumentList[]
         |              +- VariableAccess[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<capture#... of ? super T>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- PrimitiveType[@TypeMirror = "int"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.count(java.util.Iterator<?>) -> int", @MethodName = "count", @TypeMirror = "int", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           +- ArgumentList[]
         |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |                 +- ArgumentList[]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- PrimitiveType[@TypeMirror = "boolean"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "java.util.Iterator<T>.hasNext() -> boolean", @MethodName = "hasNext", @TypeMirror = "boolean", @Unchecked = false, @VarargsCall = false]
         |           +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |           |  +- ArgumentList[]
         |           +- ArgumentList[]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |  |  +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  |  +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- LocalVariableDeclaration[]
         |     |  +- ModifierList[]
         |     |  +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<T>"]
         |     |  |  +- TypeArguments[]
         |     |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |     |  +- VariableDeclarator[@TypeMirror = "void"]
         |     |     +- VariableDeclaratorId[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |     |     +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |     |        +- ArgumentList[]
         |     +- ReturnStatement[]
         |        +- ConditionalExpression[@TypeMirror = "T"]
         |           +- MethodCall[@Failed = false, @Function = "java.util.Iterator<T>.hasNext() -> boolean", @MethodName = "hasNext", @TypeMirror = "boolean", @Unchecked = false, @VarargsCall = false]
         |           |  +- VariableAccess[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |           |  +- ArgumentList[]
         |           +- MethodCall[@Failed = false, @Function = "java.util.Iterator<T>.next() -> T", @MethodName = "next", @TypeMirror = "T", @Unchecked = false, @VarargsCall = false]
         |           |  +- VariableAccess[@Name = "iter", @TypeMirror = "java.util.Iterator<T>"]
         |           |  +- ArgumentList[]
         |           +- NullLiteral[@TypeMirror = "null"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |  |  +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  |  +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> last(java.util.Iterator<? extends T>) -> T", @MethodName = "last", @TypeMirror = "T", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           +- ArgumentList[]
         |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |                 +- ArgumentList[]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "java.util.List<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T> toList(java.util.Iterator<? extends T>) -> java.util.List<T>", @MethodName = "toList", @TypeMirror = "java.util.List<T>", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
         |           +- ArgumentList[]
         |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.iterator() -> java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
         |                 +- ArgumentList[]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- TypeParameters[]
         |  |  +- TypeParameter[@TypeMirror = "R"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |  +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.lang.Class<? extends R>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Class<? extends R>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? extends R"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |     +- VariableDeclaratorId[@Name = "r1Class", @TypeMirror = "java.lang.Class<? extends R>"]
         |  +- Block[]
         |     +- ForeachStatement[]
         |     |  +- LocalVariableDeclaration[]
         |     |  |  +- ModifierList[]
         |     |  |  +- ClassOrInterfaceType[@TypeMirror = "T"]
         |     |  |  +- VariableDeclarator[@TypeMirror = "void"]
         |     |  |     +- VariableDeclaratorId[@Name = "t", @TypeMirror = "T"]
         |     |  +- ThisExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>"]
         |     |  +- Block[]
         |     |     +- IfStatement[]
         |     |        +- MethodCall[@Failed = false, @Function = "java.lang.Class<capture#... of ? extends R>.isInstance(java.lang.Object) -> boolean", @MethodName = "isInstance", @TypeMirror = "boolean", @Unchecked = false, @VarargsCall = false]
         |     |        |  +- VariableAccess[@Name = "r1Class", @TypeMirror = "java.lang.Class<capture#... of ? extends R>"]
         |     |        |  +- ArgumentList[]
         |     |        |     +- VariableAccess[@Name = "t", @TypeMirror = "T"]
         |     |        +- Block[]
         |     |           +- ReturnStatement[]
         |     |              +- MethodCall[@Failed = false, @Function = "java.lang.Class<capture#... of ? extends R>.cast(java.lang.Object) -> capture#... of ? extends R", @MethodName = "cast", @TypeMirror = "capture#... of ? extends R", @Unchecked = false, @VarargsCall = false]
         |     |                 +- VariableAccess[@Name = "r1Class", @TypeMirror = "java.lang.Class<capture#... of ? extends R>"]
         |     |                 +- ArgumentList[]
         |     |                    +- VariableAccess[@Name = "t", @TypeMirror = "T"]
         |     +- ReturnStatement[]
         |        +- NullLiteral[@TypeMirror = "null"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |  |  +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  |  +- Annotation[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "org.checkerframework.checker.nullness.qual.Nullable"]
         |  +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Predicate<? super T>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- WildcardType[@TypeMirror = "? super T"]
         |  |     |        +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     +- VariableDeclaratorId[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<? super T>"]
         |  +- Block[]
         |     +- ForeachStatement[]
         |     |  +- LocalVariableDeclaration[]
         |     |  |  +- ModifierList[]
         |     |  |  +- ClassOrInterfaceType[@TypeMirror = "T"]
         |     |  |  +- VariableDeclarator[@TypeMirror = "void"]
         |     |  |     +- VariableDeclaratorId[@Name = "t", @TypeMirror = "T"]
         |     |  +- ThisExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>"]
         |     |  +- Block[]
         |     |     +- IfStatement[]
         |     |        +- MethodCall[@Failed = false, @Function = "java.util.function.Predicate<capture#... of ? super T>.test(capture#... of ? super T) -> boolean", @MethodName = "test", @TypeMirror = "boolean", @Unchecked = false, @VarargsCall = false]
         |     |        |  +- VariableAccess[@Name = "predicate", @TypeMirror = "java.util.function.Predicate<capture#... of ? super T>"]
         |     |        |  +- ArgumentList[]
         |     |        |     +- VariableAccess[@Name = "t", @TypeMirror = "T"]
         |     |        +- Block[]
         |     |           +- ReturnStatement[]
         |     |              +- VariableAccess[@Name = "t", @TypeMirror = "T"]
         |     +- ReturnStatement[]
         |        +- NullLiteral[@TypeMirror = "null"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.StreamImpl.<T extends net.sourceforge.pmd.lang.ast.Node> fromNonNullList(java.util.List<T>) -> net.sourceforge.pmd.lang.ast.NodeStream<T>", @MethodName = "fromNonNullList", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<T>", @Unchecked = false, @VarargsCall = false]
         |           +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.StreamImpl"]
         |           |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.StreamImpl"]
         |           +- ArgumentList[]
         |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.toList() -> java.util.List<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "toList", @TypeMirror = "java.util.List<T>", @Unchecked = false, @VarargsCall = false]
         |                 +- ArgumentList[]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  +- TypeParameters[]
         |  |  +- TypeParameter[@TypeMirror = "R"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream<R>"]
         |  |  +- TypeArguments[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  +- FormalParameters[]
         |  |  +- FormalParameter[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<R>>"]
         |  |     +- ModifierList[]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<R>>"]
         |  |     |  +- TypeArguments[]
         |  |     |     +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<T>"]
         |  |     |     |  +- TypeArguments[]
         |  |     |     |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |  |     |     +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<R>"]
         |  |     |        +- TypeArguments[]
         |  |     |           +- ClassOrInterfaceType[@TypeMirror = "R"]
         |  |     +- VariableDeclaratorId[@Name = "fun", @TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<R>>"]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- ConstructorCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>#IteratorMapping<R extends net.sourceforge.pmd.lang.ast.Node>.new(java.util.function.Function<java.util.Iterator<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.Iterator<R extends net.sourceforge.pmd.lang.ast.Node>>) -> net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>#IteratorMapping<R extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "new", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>#IteratorMapping<R extends net.sourceforge.pmd.lang.ast.Node>", @Unchecked = false, @VarargsCall = false]
         |           +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>#IteratorMapping<S extends net.sourceforge.pmd.lang.ast.Node>"]
         |           |  +- TypeArguments[]
         |           +- ArgumentList[]
         |              +- VariableAccess[@Name = "fun", @TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<R>>"]
         +- MethodDeclaration[]
         |  +- ModifierList[]
         |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |  +- ClassOrInterfaceType[@TypeMirror = "java.lang.String"]
         |  +- FormalParameters[]
         |  +- Block[]
         |     +- ReturnStatement[]
         |        +- InfixExpression[@TypeMirror = "java.lang.String"]
         |           +- InfixExpression[@TypeMirror = "java.lang.String"]
         |           |  +- InfixExpression[@TypeMirror = "java.lang.String"]
         |           |  |  +- MethodCall[@Failed = false, @Function = "java.lang.Class<capture#... of ? extends net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream>.getSimpleName() -> java.lang.String", @MethodName = "getSimpleName", @TypeMirror = "java.lang.String", @Unchecked = false, @VarargsCall = false]
         |           |  |  |  +- MethodCall[@Failed = false, @Function = "java.lang.Object.getClass() -> java.lang.Class<? extends net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream>", @MethodName = "getClass", @TypeMirror = "java.lang.Class<? extends net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream>", @Unchecked = false, @VarargsCall = false]
         |           |  |  |  |  +- ArgumentList[]
         |           |  |  |  +- ArgumentList[]
         |           |  |  +- StringLiteral[@TypeMirror = "java.lang.String"]
         |           |  +- MethodCall[@Failed = false, @Function = "java.util.stream.Stream<java.lang.String>.<R, A> collect(java.util.stream.Collector<? super java.lang.String, capture#... of ?, java.lang.String>) -> java.lang.String", @MethodName = "collect", @TypeMirror = "java.lang.String", @Unchecked = false, @VarargsCall = false]
         |           |     +- MethodCall[@Failed = false, @Function = "java.util.stream.Stream<T>.<R> map(java.util.function.Function<? super T, ? extends java.lang.String>) -> java.util.stream.Stream<java.lang.String>", @MethodName = "map", @TypeMirror = "java.util.stream.Stream<java.lang.String>", @Unchecked = false, @VarargsCall = false]
         |           |     |  +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>.toStream() -> java.util.stream.Stream<T extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "toStream", @TypeMirror = "java.util.stream.Stream<T>", @Unchecked = false, @VarargsCall = false]
         |           |     |  |  +- ArgumentList[]
         |           |     |  +- ArgumentList[]
         |           |     |     +- MethodReference[@TypeMirror = "java.util.function.Function<T, java.lang.String>"]
         |           |     |        +- TypeExpression[@TypeMirror = "java.util.Objects"]
         |           |     |           +- ClassOrInterfaceType[@TypeMirror = "java.util.Objects"]
         |           |     +- ArgumentList[]
         |           |        +- MethodCall[@Failed = false, @Function = "java.util.stream.Collectors.joining(java.lang.CharSequence) -> java.util.stream.Collector<java.lang.CharSequence, ?, java.lang.String>", @MethodName = "joining", @TypeMirror = "java.util.stream.Collector<java.lang.CharSequence, ?, java.lang.String>", @Unchecked = false, @VarargsCall = false]
         |           |           +- TypeExpression[@TypeMirror = "java.util.stream.Collectors"]
         |           |           |  +- ClassOrInterfaceType[@TypeMirror = "java.util.stream.Collectors"]
         |           |           +- ArgumentList[]
         |           |              +- StringLiteral[@TypeMirror = "java.lang.String"]
         |           +- StringLiteral[@TypeMirror = "java.lang.String"]
         +- ClassOrInterfaceDeclaration[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>#IteratorMapping<S extends net.sourceforge.pmd.lang.ast.Node>"]
         |  +- ModifierList[]
         |  +- TypeParameters[]
         |  |  +- TypeParameter[@TypeMirror = "S"]
         |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
         |  +- ExtendsList[]
         |  |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<S>"]
         |  |     +- TypeArguments[]
         |  |        +- ClassOrInterfaceType[@TypeMirror = "S"]
         |  +- ClassOrInterfaceBody[]
         |     +- FieldDeclaration[]
         |     |  +- ModifierList[]
         |     |  +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<S>>"]
         |     |  |  +- TypeArguments[]
         |     |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<T>"]
         |     |  |     |  +- TypeArguments[]
         |     |  |     |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |     |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<S>"]
         |     |  |        +- TypeArguments[]
         |     |  |           +- ClassOrInterfaceType[@TypeMirror = "S"]
         |     |  +- VariableDeclarator[@TypeMirror = "void"]
         |     |     +- VariableDeclaratorId[@Name = "fun", @TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<S>>"]
         |     +- ConstructorDeclaration[]
         |     |  +- ModifierList[]
         |     |  +- FormalParameters[]
         |     |  |  +- FormalParameter[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<S>>"]
         |     |  |     +- ModifierList[]
         |     |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<S>>"]
         |     |  |     |  +- TypeArguments[]
         |     |  |     |     +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<T>"]
         |     |  |     |     |  +- TypeArguments[]
         |     |  |     |     |     +- ClassOrInterfaceType[@TypeMirror = "T"]
         |     |  |     |     +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<S>"]
         |     |  |     |        +- TypeArguments[]
         |     |  |     |           +- ClassOrInterfaceType[@TypeMirror = "S"]
         |     |  |     +- VariableDeclaratorId[@Name = "fun", @TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<S>>"]
         |     |  +- Block[]
         |     |     +- ExpressionStatement[]
         |     |        +- AssignmentExpression[@TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<S>>"]
         |     |           +- FieldAccess[@Name = "fun", @TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<S>>"]
         |     |           |  +- ThisExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>#IteratorMapping<S extends net.sourceforge.pmd.lang.ast.Node>"]
         |     |           +- VariableAccess[@Name = "fun", @TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<S>>"]
         |     +- MethodDeclaration[]
         |        +- ModifierList[]
         |        |  +- Annotation[@TypeMirror = "java.lang.Override"]
         |        |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
         |        +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<S>"]
         |        |  +- TypeArguments[]
         |        |     +- ClassOrInterfaceType[@TypeMirror = "S"]
         |        +- FormalParameters[]
         |        +- Block[]
         |           +- ReturnStatement[]
         |              +- MethodCall[@Failed = false, @Function = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<S>>.apply(java.util.Iterator<T>) -> java.util.Iterator<S>", @MethodName = "apply", @TypeMirror = "java.util.Iterator<S>", @Unchecked = true, @VarargsCall = false]
         |                 +- VariableAccess[@Name = "fun", @TypeMirror = "java.util.function.Function<java.util.Iterator<T>, java.util.Iterator<S>>"]
         |                 +- ArgumentList[]
         |                    +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream.iterator() -> java.util.Iterator", @MethodName = "iterator", @TypeMirror = "java.util.Iterator", @Unchecked = false, @VarargsCall = false]
         |                       +- ThisExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream"]
         |                       |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream"]
         |                       +- ArgumentList[]
         +- ClassOrInterfaceDeclaration[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T extends net.sourceforge.pmd.lang.ast.Node, S extends net.sourceforge.pmd.lang.ast.Node>"]
            +- ModifierList[]
            +- TypeParameters[]
            |  +- TypeParameter[@TypeMirror = "T"]
            |  |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
            |  +- TypeParameter[@TypeMirror = "S"]
            |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.Node"]
            +- ExtendsList[]
            |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<S>"]
            |     +- TypeArguments[]
            |        +- ClassOrInterfaceType[@TypeMirror = "S"]
            +- ImplementsList[]
            |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<S>"]
            |     +- TypeArguments[]
            |        +- ClassOrInterfaceType[@TypeMirror = "S"]
            +- ClassOrInterfaceBody[]
               +- FieldDeclaration[]
               |  +- ModifierList[]
               |  +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |  |  +- TypeArguments[]
               |  |     +- WildcardType[@TypeMirror = "? super T"]
               |  |     |  +- ClassOrInterfaceType[@TypeMirror = "T"]
               |  |     +- WildcardType[@TypeMirror = "? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>"]
               |  |        +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>"]
               |  |           +- TypeArguments[]
               |  |              +- WildcardType[@TypeMirror = "? extends S"]
               |  |                 +- ClassOrInterfaceType[@TypeMirror = "S"]
               |  +- VariableDeclarator[@TypeMirror = "void"]
               |     +- VariableDeclaratorId[@Name = "fun", @TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               +- FieldDeclaration[]
               |  +- ModifierList[]
               |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               |  +- VariableDeclarator[@TypeMirror = "void"]
               |     +- VariableDeclaratorId[@Name = "walker", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               +- FieldDeclaration[]
               |  +- ModifierList[]
               |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |  |  +- TypeArguments[]
               |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
               |  +- VariableDeclarator[@TypeMirror = "void"]
               |     +- VariableDeclaratorId[@Name = "upstream", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               +- ConstructorDeclaration[]
               |  +- ModifierList[]
               |  +- FormalParameters[]
               |  |  +- FormalParameter[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |  |  |  +- ModifierList[]
               |  |  |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |  |  |  |  +- TypeArguments[]
               |  |  |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
               |  |  |  +- VariableDeclaratorId[@Name = "upstream", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |  |  +- FormalParameter[@TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |  |  |  +- ModifierList[]
               |  |  |  +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |  |  |  |  +- TypeArguments[]
               |  |  |  |     +- WildcardType[@TypeMirror = "? super T"]
               |  |  |  |     |  +- ClassOrInterfaceType[@TypeMirror = "T"]
               |  |  |  |     +- WildcardType[@TypeMirror = "? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>"]
               |  |  |  |        +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>"]
               |  |  |  |           +- TypeArguments[]
               |  |  |  |              +- WildcardType[@TypeMirror = "? extends S"]
               |  |  |  |                 +- ClassOrInterfaceType[@TypeMirror = "S"]
               |  |  |  +- VariableDeclaratorId[@Name = "fun", @TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |  |  +- FormalParameter[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               |  |     +- ModifierList[]
               |  |     +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               |  |     +- VariableDeclaratorId[@Name = "walker", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               |  +- Block[]
               |     +- ExpressionStatement[]
               |     |  +- AssignmentExpression[@TypeMirror = "java.util.function.Function<capture#... of ? super T, capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |     |     +- FieldAccess[@Name = "fun", @TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |     |     |  +- ThisExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T extends net.sourceforge.pmd.lang.ast.Node, S extends net.sourceforge.pmd.lang.ast.Node>"]
               |     |     +- VariableAccess[@Name = "fun", @TypeMirror = "java.util.function.Function<capture#... of ? super T, capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |     +- ExpressionStatement[]
               |     |  +- AssignmentExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               |     |     +- FieldAccess[@Name = "walker", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               |     |     |  +- ThisExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T extends net.sourceforge.pmd.lang.ast.Node, S extends net.sourceforge.pmd.lang.ast.Node>"]
               |     |     +- VariableAccess[@Name = "walker", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               |     +- ExpressionStatement[]
               |        +- AssignmentExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |           +- FieldAccess[@Name = "upstream", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |           |  +- ThisExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T extends net.sourceforge.pmd.lang.ast.Node, S extends net.sourceforge.pmd.lang.ast.Node>"]
               |           +- VariableAccess[@Name = "upstream", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               +- ConstructorDeclaration[]
               |  +- ModifierList[]
               |  +- FormalParameters[]
               |  |  +- FormalParameter[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |  |  |  +- ModifierList[]
               |  |  |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |  |  |  |  +- TypeArguments[]
               |  |  |  |     +- ClassOrInterfaceType[@TypeMirror = "T"]
               |  |  |  +- VariableDeclaratorId[@Name = "upstream", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |  |  +- FormalParameter[@TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |  |     +- ModifierList[]
               |  |     +- ClassOrInterfaceType[@TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |  |     |  +- TypeArguments[]
               |  |     |     +- WildcardType[@TypeMirror = "? super T"]
               |  |     |     |  +- ClassOrInterfaceType[@TypeMirror = "T"]
               |  |     |     +- WildcardType[@TypeMirror = "? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>"]
               |  |     |        +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>"]
               |  |     |           +- TypeArguments[]
               |  |     |              +- WildcardType[@TypeMirror = "? extends S"]
               |  |     |                 +- ClassOrInterfaceType[@TypeMirror = "S"]
               |  |     +- VariableDeclaratorId[@Name = "fun", @TypeMirror = "java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |  +- Block[]
               |     +- ExplicitConstructorInvocation[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T extends net.sourceforge.pmd.lang.ast.Node, S extends net.sourceforge.pmd.lang.ast.Node>.new(net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T extends net.sourceforge.pmd.lang.ast.Node>, java.util.function.Function<? super T extends net.sourceforge.pmd.lang.ast.Node, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S extends net.sourceforge.pmd.lang.ast.Node>>, net.sourceforge.pmd.lang.ast.internal.TreeWalker) -> net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T extends net.sourceforge.pmd.lang.ast.Node, S extends net.sourceforge.pmd.lang.ast.Node>", @MethodName = "new", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T extends net.sourceforge.pmd.lang.ast.Node, S extends net.sourceforge.pmd.lang.ast.Node>", @Unchecked = false, @VarargsCall = false]
               |        +- ArgumentList[]
               |           +- VariableAccess[@Name = "upstream", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |           +- VariableAccess[@Name = "fun", @TypeMirror = "java.util.function.Function<capture#... of ? super T, capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |           +- FieldAccess[@Name = "DEFAULT", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               |              +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               |                 +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               +- MethodDeclaration[]
               |  +- ModifierList[]
               |  |  +- Annotation[@TypeMirror = "java.lang.Override"]
               |  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
               |  +- ClassOrInterfaceType[@TypeMirror = "java.util.Iterator<S>"]
               |  |  +- TypeArguments[]
               |  |     +- ClassOrInterfaceType[@TypeMirror = "S"]
               |  +- FormalParameters[]
               |  +- Block[]
               |     +- ReturnStatement[]
               |        +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.internal.util.IteratorUtil.<T, R> flatMap(java.util.Iterator<? extends T>, java.util.function.Function<? super T, ? extends java.util.Iterator<? extends S>>) -> java.util.Iterator<S>", @MethodName = "flatMap", @TypeMirror = "java.util.Iterator<S>", @Unchecked = false, @VarargsCall = false]
               |           +- TypeExpression[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
               |           |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.internal.util.IteratorUtil"]
               |           +- ArgumentList[]
               |              +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>.iterator() -> java.util.Iterator<T>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<T>", @Unchecked = false, @VarargsCall = false]
               |              |  +- VariableAccess[@Name = "upstream", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
               |              |  +- ArgumentList[]
               |              +- LambdaExpression[@TypeMirror = "java.util.function.Function<T, java.util.Iterator<? extends S>>"]
               |                 +- LambdaParameterList[]
               |                 |  +- LambdaParameter[@TypeMirror = "T"]
               |                 |     +- ModifierList[]
               |                 |     +- VariableDeclaratorId[@Name = "t", @TypeMirror = "T"]
               |                 +- Block[]
               |                    +- LocalVariableDeclaration[]
               |                    |  +- ModifierList[]
               |                    |  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>"]
               |                    |  |  +- TypeArguments[]
               |                    |  |     +- WildcardType[@TypeMirror = "? extends S"]
               |                    |  |        +- ClassOrInterfaceType[@TypeMirror = "S"]
               |                    |  +- VariableDeclarator[@TypeMirror = "void"]
               |                    |     +- VariableDeclaratorId[@Name = "app", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>"]
               |                    |     +- MethodCall[@Failed = false, @Function = "java.util.function.Function<capture#... of ? super T, capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>.apply(capture#... of ? super T) -> capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>", @MethodName = "apply", @TypeMirror = "capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>", @Unchecked = false, @VarargsCall = false]
               |                    |        +- VariableAccess[@Name = "fun", @TypeMirror = "java.util.function.Function<capture#... of ? super T, capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
               |                    |        +- ArgumentList[]
               |                    |           +- VariableAccess[@Name = "t", @TypeMirror = "T"]
               |                    +- ReturnStatement[]
               |                       +- MethodCall[@Failed = false, @Function = "java.lang.Iterable<capture#... of ? extends S>.iterator() -> java.util.Iterator<capture#... of ? extends S>", @MethodName = "iterator", @TypeMirror = "java.util.Iterator<capture#... of ? extends S>", @Unchecked = false, @VarargsCall = false]
               |                          +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.TreeWalker.<T extends net.sourceforge.pmd.lang.ast.Node> apply(net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<capture#... of ? extends S>) -> net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<capture#... of ? extends S>", @MethodName = "apply", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<capture#... of ? extends S>", @Unchecked = false, @VarargsCall = false]
               |                          |  +- VariableAccess[@Name = "walker", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
               |                          |  +- ArgumentList[]
               |                          |     +- VariableAccess[@Name = "app", @TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<capture#... of ? extends S>"]
               |                          +- ArgumentList[]
               +- MethodDeclaration[]
                  +- ModifierList[]
                  |  +- Annotation[@TypeMirror = "java.lang.Override"]
                  |     +- ClassOrInterfaceType[@TypeMirror = "java.lang.Override"]
                  +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<S>"]
                  |  +- TypeArguments[]
                  |     +- ClassOrInterfaceType[@TypeMirror = "S"]
                  +- FormalParameters[]
                  |  +- FormalParameter[@TypeMirror = "boolean"]
                  |     +- ModifierList[]
                  |     +- PrimitiveType[@TypeMirror = "boolean"]
                  |     +- VariableDeclaratorId[@Name = "cross", @TypeMirror = "boolean"]
                  +- Block[]
                     +- ReturnStatement[]
                        +- ConditionalExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<S>"]
                           +- InfixExpression[@TypeMirror = "boolean"]
                           |  +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.TreeWalker.isCrossFindBoundaries() -> boolean", @MethodName = "isCrossFindBoundaries", @TypeMirror = "boolean", @Unchecked = false, @VarargsCall = false]
                           |  |  +- VariableAccess[@Name = "walker", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
                           |  |  +- ArgumentList[]
                           |  +- VariableAccess[@Name = "cross", @TypeMirror = "boolean"]
                           +- ThisExpression[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T extends net.sourceforge.pmd.lang.ast.Node, S extends net.sourceforge.pmd.lang.ast.Node>"]
                           +- ConstructorCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T, S>.new(net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>, java.util.function.Function<? super T, ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>, net.sourceforge.pmd.lang.ast.internal.TreeWalker) -> net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T, S>", @MethodName = "new", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T, S>", @Unchecked = false, @VarargsCall = false]
                              +- ClassOrInterfaceType[@TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream$DescendantMapping<T extends net.sourceforge.pmd.lang.ast.Node, S extends net.sourceforge.pmd.lang.ast.Node>"]
                              |  +- TypeArguments[]
                              +- ArgumentList[]
                                 +- VariableAccess[@Name = "upstream", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream<T>"]
                                 +- VariableAccess[@Name = "fun", @TypeMirror = "java.util.function.Function<capture#... of ? super T, capture#... of ? extends net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<? extends S>>"]
                                 +- MethodCall[@Failed = false, @Function = "net.sourceforge.pmd.lang.ast.internal.TreeWalker.crossFindBoundaries(boolean) -> net.sourceforge.pmd.lang.ast.internal.TreeWalker", @MethodName = "crossFindBoundaries", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker", @Unchecked = false, @VarargsCall = false]
                                    +- VariableAccess[@Name = "walker", @TypeMirror = "net.sourceforge.pmd.lang.ast.internal.TreeWalker"]
                                    +- ArgumentList[]
                                       +- VariableAccess[@Name = "cross", @TypeMirror = "boolean"]
